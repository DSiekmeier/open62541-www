

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Examining and interacting with node relations &mdash; open62541 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="open62541 1 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> open62541
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building the Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-the-single-file-release">Building the Single-File Release</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-with-cmake-on-ubuntu-or-debian">Building with CMake on Ubuntu or Debian</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-with-cmake-on-windows-visual-studio">Building with CMake on Windows (Visual Studio)</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#build-options">Build Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="datatypes.html">Data Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="datatypes.html#generic-data-type-handling">Generic Data Type Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="datatypes.html#array-handling">Array Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="datatypes.html#builtin-data-types">Builtin Data Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#number-types">Number-Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-string">UA_String</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-datetime">UA_DateTime</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-guid">UA_Guid</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-bytestring">UA_ByteString</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-xmlelement">UA_XmlElement</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-nodeid">UA_NodeId</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-expandednodeid">UA_ExpandedNodeId</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-statuscode">UA_StatusCode</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-qualifiedname">UA_QualifiedName</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-localizedtext">UA_LocalizedText</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-extensionobject">UA_ExtensionObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-datavalue">UA_DataValue</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-variant">UA_Variant</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatypes.html#ua-diagnosticinfo">UA_DiagnosticInfo</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">open62541</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Examining and interacting with node relations</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/tutorial_noderelations.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="examining-and-interacting-with-node-relations">
<h1>Examining and interacting with node relations<a class="headerlink" href="#examining-and-interacting-with-node-relations" title="Permalink to this headline">¶</a></h1>
<p>In the past tutorials you learned to compile the stack in various configurations, create/delete nodes and manage variables. The core of OPC UA are it&#8217;s data modelling capabilities, and you will invariably find yourself confronted to investigate these relations during runtime. This tutorial will show you how to interact with object and types hierarchies and how to create your own.</p>
<div class="section" id="compile-xml-namespaces">
<h2>Compile XML Namespaces<a class="headerlink" href="#compile-xml-namespaces" title="Permalink to this headline">¶</a></h2>
<p>So far we have made due with the hardcoded mini-namespace in the server stack. When writing an application, it is more then likely that you will want to create your own data models using some comfortable GUI based tools like UA Modeller. Most tools can export data to the OPC UA XML specification. open62541 contains a python based namespace compiler that can embed datamodels contained in XML files into the server stack.</p>
<p>Note beforehand that the pyUANamespace compiler you can find in the <em>tools</em> subfolder is <em>not</em> a XML transformation tool but a compiler. That means that it will create an internal representation (dAST) when parsing the XML files and attempt to understand this representation in order to generate C Code. In consequence, the compiler will refuse to print any inconsistencies or invalid nodes.</p>
<p>As an example, we will create a simple object model using UA Modeller and embed this into the servers nodeset, which is exported to the following XML file:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;UANodeSet xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:uax=&quot;http://opcfoundation.org/UA/2008/02/Types.xsd&quot; xmlns=&quot;http://opcfoundation.org/UA/2011/03/UANodeSet.xsd&quot; xmlns:s1=&quot;http://yourorganisation.org/example_nodeset/&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
    &lt;NamespaceUris&gt;
        &lt;Uri&gt;http://yourorganisation.org/example_nodeset/&lt;/Uri&gt;
    &lt;/NamespaceUris&gt;
    &lt;Aliases&gt;
        &lt;Alias Alias=&quot;Boolean&quot;&gt;i=1&lt;/Alias&gt;
        &lt;Alias Alias=&quot;UInt32&quot;&gt;i=7&lt;/Alias&gt;
        &lt;Alias Alias=&quot;String&quot;&gt;i=12&lt;/Alias&gt;
        &lt;Alias Alias=&quot;HasModellingRule&quot;&gt;i=37&lt;/Alias&gt;
        &lt;Alias Alias=&quot;HasTypeDefinition&quot;&gt;i=40&lt;/Alias&gt;
        &lt;Alias Alias=&quot;HasSubtype&quot;&gt;i=45&lt;/Alias&gt;
        &lt;Alias Alias=&quot;HasProperty&quot;&gt;i=46&lt;/Alias&gt;
        &lt;Alias Alias=&quot;HasComponent&quot;&gt;i=47&lt;/Alias&gt;
        &lt;Alias Alias=&quot;Argument&quot;&gt;i=296&lt;/Alias&gt;
    &lt;/Aliases&gt;
    &lt;Extensions&gt;
        &lt;Extension&gt;
            &lt;ModelInfo Tool=&quot;UaModeler&quot; Hash=&quot;Zs8w1AQI71W8P/GOk3k/xQ==&quot; Version=&quot;1.3.4&quot;/&gt;
        &lt;/Extension&gt;
    &lt;/Extensions&gt;
    &lt;UAReferenceType NodeId=&quot;ns=1;i=4001&quot; BrowseName=&quot;1:providesInputTo&quot;&gt;
        &lt;DisplayName&gt;providesInputTo&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasSubtype&quot; IsForward=&quot;false&quot;&gt;i=33&lt;/Reference&gt;
        &lt;/References&gt;
        &lt;InverseName Locale=&quot;en_US&quot;&gt;inputProcidedBy&lt;/InverseName&gt;
    &lt;/UAReferenceType&gt;
    &lt;UAObjectType IsAbstract=&quot;true&quot; NodeId=&quot;ns=1;i=1001&quot; BrowseName=&quot;1:FieldDevice&quot;&gt;
        &lt;DisplayName&gt;FieldDevice&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasSubtype&quot; IsForward=&quot;false&quot;&gt;i=58&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=6001&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=6002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAObjectType&gt;
    &lt;UAVariable DataType=&quot;String&quot; ParentNodeId=&quot;ns=1;i=1001&quot; NodeId=&quot;ns=1;i=6001&quot; BrowseName=&quot;1:ManufacturerName&quot; UserAccessLevel=&quot;3&quot; AccessLevel=&quot;3&quot;&gt;
        &lt;DisplayName&gt;ManufacturerName&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=63&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1001&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAVariable&gt;
    &lt;UAVariable DataType=&quot;String&quot; ParentNodeId=&quot;ns=1;i=1001&quot; NodeId=&quot;ns=1;i=6002&quot; BrowseName=&quot;1:ModelName&quot; UserAccessLevel=&quot;3&quot; AccessLevel=&quot;3&quot;&gt;
        &lt;DisplayName&gt;ModelName&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=63&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1001&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAVariable&gt;
    &lt;UAObjectType NodeId=&quot;ns=1;i=1002&quot; BrowseName=&quot;1:Pump&quot;&gt;
        &lt;DisplayName&gt;Pump&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=6003&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=6004&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasSubtype&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1001&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=7001&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot;&gt;ns=1;i=7002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAObjectType&gt;
    &lt;UAVariable DataType=&quot;Boolean&quot; ParentNodeId=&quot;ns=1;i=1002&quot; NodeId=&quot;ns=1;i=6003&quot; BrowseName=&quot;1:isOn&quot; UserAccessLevel=&quot;3&quot; AccessLevel=&quot;3&quot;&gt;
        &lt;DisplayName&gt;isOn&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=63&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAVariable&gt;
    &lt;UAVariable DataType=&quot;UInt32&quot; ParentNodeId=&quot;ns=1;i=1002&quot; NodeId=&quot;ns=1;i=6004&quot; BrowseName=&quot;1:MotorRPM&quot; UserAccessLevel=&quot;3&quot; AccessLevel=&quot;3&quot;&gt;
        &lt;DisplayName&gt;MotorRPM&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=63&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAVariable&gt;
    &lt;UAMethod ParentNodeId=&quot;ns=1;i=1002&quot; NodeId=&quot;ns=1;i=7001&quot; BrowseName=&quot;1:startPump&quot;&gt;
        &lt;DisplayName&gt;startPump&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasProperty&quot;&gt;ns=1;i=6005&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAMethod&gt;
    &lt;UAVariable DataType=&quot;Argument&quot; ParentNodeId=&quot;ns=1;i=7001&quot; ValueRank=&quot;1&quot; NodeId=&quot;ns=1;i=6005&quot; ArrayDimensions=&quot;1&quot; BrowseName=&quot;OutputArguments&quot;&gt;
        &lt;DisplayName&gt;OutputArguments&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasProperty&quot; IsForward=&quot;false&quot;&gt;ns=1;i=7001&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=68&lt;/Reference&gt;
        &lt;/References&gt;
        &lt;Value&gt;
            &lt;ListOfExtensionObject&gt;
                &lt;ExtensionObject&gt;
                    &lt;TypeId&gt;
                        &lt;Identifier&gt;i=297&lt;/Identifier&gt;
                    &lt;/TypeId&gt;
                    &lt;Body&gt;
                        &lt;Argument&gt;
                            &lt;Name&gt;started&lt;/Name&gt;
                            &lt;DataType&gt;
                                &lt;Identifier&gt;i=1&lt;/Identifier&gt;
                            &lt;/DataType&gt;
                            &lt;ValueRank&gt;-1&lt;/ValueRank&gt;
                            &lt;ArrayDimensions&gt;&lt;/ArrayDimensions&gt;
                            &lt;Description/&gt;
                        &lt;/Argument&gt;
                    &lt;/Body&gt;
                &lt;/ExtensionObject&gt;
            &lt;/ListOfExtensionObject&gt;
        &lt;/Value&gt;
    &lt;/UAVariable&gt;
    &lt;UAMethod ParentNodeId=&quot;ns=1;i=1002&quot; NodeId=&quot;ns=1;i=7002&quot; BrowseName=&quot;1:stopPump&quot;&gt;
        &lt;DisplayName&gt;stopPump&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasProperty&quot;&gt;ns=1;i=6006&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasComponent&quot; IsForward=&quot;false&quot;&gt;ns=1;i=1002&lt;/Reference&gt;
        &lt;/References&gt;
    &lt;/UAMethod&gt;
    &lt;UAVariable DataType=&quot;Argument&quot; ParentNodeId=&quot;ns=1;i=7002&quot; ValueRank=&quot;1&quot; NodeId=&quot;ns=1;i=6006&quot; ArrayDimensions=&quot;1&quot; BrowseName=&quot;OutputArguments&quot;&gt;
        &lt;DisplayName&gt;OutputArguments&lt;/DisplayName&gt;
        &lt;References&gt;
            &lt;Reference ReferenceType=&quot;HasModellingRule&quot;&gt;i=78&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasProperty&quot; IsForward=&quot;false&quot;&gt;ns=1;i=7002&lt;/Reference&gt;
            &lt;Reference ReferenceType=&quot;HasTypeDefinition&quot;&gt;i=68&lt;/Reference&gt;
        &lt;/References&gt;
        &lt;Value&gt;
            &lt;ListOfExtensionObject&gt;
                &lt;ExtensionObject&gt;
                    &lt;TypeId&gt;
                        &lt;Identifier&gt;i=297&lt;/Identifier&gt;
                    &lt;/TypeId&gt;
                    &lt;Body&gt;
                        &lt;Argument&gt;
                            &lt;Name&gt;stopped&lt;/Name&gt;
                            &lt;DataType&gt;
                                &lt;Identifier&gt;i=1&lt;/Identifier&gt;
                            &lt;/DataType&gt;
                            &lt;ValueRank&gt;-1&lt;/ValueRank&gt;
                            &lt;ArrayDimensions&gt;&lt;/ArrayDimensions&gt;
                            &lt;Description/&gt;
                        &lt;/Argument&gt;
                    &lt;/Body&gt;
                &lt;/ExtensionObject&gt;
            &lt;/ListOfExtensionObject&gt;
        &lt;/Value&gt;
    &lt;/UAVariable&gt;
&lt;/UANodeSet&gt;
</pre></div>
</div>
<p>Or, more consiscly, this:</p>
<div class="highlight-python"><div class="highlight"><pre>+------------------+
|  &lt;&lt;ObjectType&gt;&gt;  |
|   FieldDevice    |
+------------------+
          |              +------------------+
          |              |   &lt;&lt;Variable&gt;&gt;   |
          |-------------&gt;| ManufacturerName |
          | hasComponent +------------------+
          |              +------------------+
          |              |   &lt;&lt;Variable&gt;&gt;   |
          |-------------&gt;|    ModelName     |
          | hasComponent +------------------+
          |              +----------------+
          |              | &lt;&lt;ObjectType&gt;&gt; |
          &#39;-------------&gt;|      Pump      |
             hasSubtype  +----------------+
                                  |
                                  |
                                  |                +------------------+
                                  |                |   &lt;&lt;Variable&gt;&gt;   |
                                  |---------------&gt;|     MotorRPM     |
                                  |  hasComponent  +------------------+
                                  |                +------------------+
                                  |                |   &lt;&lt;Variable&gt;&gt;   |
                                  |---------------&gt;|       isOn       |
                                  |  hasComponent  +------------------+
                                  |                +------------------+    +------------------+
                                  |                |    &lt;&lt;Method&gt;&gt;    |    |   &lt;&lt;Variable&gt;&gt;   |
                                  |---------------&gt;|    startPump     |---&gt;| outputArguments  |
                                  |  hasProperty   +------------------+    +------------------+
                                  |                +------------------+    +------------------+
                                  |                |    &lt;&lt;Method&gt;&gt;    |    |   &lt;&lt;Variable&gt;&gt;   |
                                  &#39;---------------&gt;|     stopPump     |---&gt;| outputArguments  |
                                     hasProperty   +------------------+    +------------------+
</pre></div>
</div>
<p>UA Modeler prepends the namespace qualifier &#8220;uax:&#8221; to some fields - this is not supported by the namespace compiler, who has strict aliasing rules concerning field names. If a datatype defines a field called &#8220;Argument&#8221;, the compiler expects to find &#8220;&lt;Argument&gt;&#8221; tags, not &#8220;&lt;uax:Argument&gt;&#8221;. Remove/Substitute such fields to remove namespace qualifiers.</p>
<p>The namespace compiler can be invoked manually and has numerous options. In its simplest form, an invokation will look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>python ./generate_open62541CCode.py ../schema/namespace0/Opc.Ua.NodeSet2.xml &lt;path&gt;/&lt;to&gt;/&lt;more&gt;/&lt;files&gt;.xml &lt;path&gt;/&lt;to&gt;/&lt;evenmore&gt;/&lt;files&gt;.xml myNamespace
</pre></div>
</div>
<p>The above call first parses Namespace 0, which provides all dataTypes, referenceTypes, etc.. An arbitrary amount of further xml files can be passed as options, whose nodes will be added to the abstract syntax tree. The script will then create the files <code class="docutils literal"><span class="pre">myNamespace.c</span></code> and <code class="docutils literal"><span class="pre">myNamespace.h</span></code> containing the C code necessary to instantiate those namespaces.</p>
<p>Although it is possible to run the compiler this way, it is highly discouraged. If you care to examine the CMakeLists.txt (toplevel directory), you will find that compiling the stack with <code class="docutils literal"><span class="pre">DENABLE_GENERATE_NAMESPACE0</span></code> will execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/generate_open62541CCode.py
  -i ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/NodeID_AssumeExternal.txt
  -s description -b ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/NodeID_Blacklist.txt
  ${PROJECT_SOURCE_DIR}/tools/schema/namespace0/${GENERATE_NAMESPACE0_FILE}
  ${PROJECT_BINARY_DIR}/src_generated/ua_namespaceinit_generated
</pre></div>
</div>
<p>Albeit a bit more complicates then the previous description, you can see that a the namespace 0 XML file is loaded in the line before the last, and that the output will be in <code class="docutils literal"><span class="pre">ua_namespaceinit_generated.c/h</span></code>. In order to take advantage of the namespace compiler, we will simply append our nodeset to this call and have cmake care for the rest. Modify the CMakeLists.txt line above to contain the relative path to your own XML file like this:</p>
<div class="highlight-python"><div class="highlight"><pre>COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/generate_open62541CCode.py
  -i ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/NodeID_AssumeExternal.txt
  -s description -b ${PROJECT_SOURCE_DIR}/tools/pyUANamespace/NodeID_Blacklist.txt
  ${PROJECT_SOURCE_DIR}/tools/schema/namespace0/${GENERATE_NAMESPACE0_FILE}
  ${PROJECT_SOURCE_DIR}/&lt;relative&gt;/&lt;path&gt;/&lt;to&gt;/&lt;your&gt;/&lt;namespace&gt;.xml
  ${PROJECT_BINARY_DIR}/src_generated/ua_namespaceinit_generated
</pre></div>
</div>
<p>Always make sure that your XML file comes <em>after</em> namespace 0. Also, take into consideration that any node ID&#8217;s you specify that already exist in previous files will overwrite the previous file (yes, you could intentionally overwrite the NS0 Server node if you wanted to). The namespace compiler will now automatically embedd you namespace definitions into the namespace of the server. So in total, all that was necessary was:</p>
<blockquote>
<div><ul class="simple">
<li>Creating your namespace XML description</li>
<li>Adding the relative path to the file into CMakeLists.txt</li>
<li>Compiling the stack</li>
</ul>
</div></blockquote>
<p>After adding you XML file to CMakeLists.txt, rerun cmake in your build directory and enable <code class="docutils literal"><span class="pre">DENABLE_GENERATE_NAMESPACE0</span></code>. Make especially sure that you are using the option <code class="docutils literal"><span class="pre">CMAKE_BUILD_TYPE=Debug</span></code>. The generated namespace contains more than 30000 lines of code and many strings. Optimizing this amount of code with -O2 or -Os options will require several hours on most PCs! Also make sure to enable <code class="docutils literal"><span class="pre">-DENABLE_METHODCALLS</span></code>, as namespace 0 does contain methods that need to be encoded:</p>
<div class="highlight-python"><div class="highlight"><pre>ichrispa@Cassandra:open62541/build&gt; cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_METHODCALLS=On -BUILD_EXAMPLECLIENT=On -BUILD_EXAMPLESERVER=On -DENABLE_GENERATE_NAMESPACE0=On ../
-- Git version: v0.1.0-RC4-403-g198597c-dirty
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ichrispa/work/svn/working_copies/open62541/build
ichrispa@Cassandra:open62541/build&gt; make
[  3%] Generating src_generated/ua_nodeids.h
[  6%] Generating src_generated/ua_types_generated.c, src_generated/ua_types_generated.h
[ 10%] Generating src_generated/ua_transport_generated.c, src_generated/ua_transport_generated.h
[ 13%] Generating src_generated/ua_namespaceinit_generated.c, src_generated/ua_namespaceinit_generated.h
</pre></div>
</div>
<p>At this point, the make process will most likely hang for 30-60s until the namespace is parsed, checked, linked and finally generated (be pacient). It sould continue as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>Scanning dependencies of target open62541-object
[ 17%] Building C object CMakeFiles/open62541-object.dir/src/ua_types.c.o
[ 20%] Building C object CMakeFiles/open62541-object.dir/src/ua_types_encoding_binary.c.o
[ 24%] Building C object CMakeFiles/open62541-object.dir/src_generated/ua_types_generated.c.o
[ 27%] Building C object CMakeFiles/open62541-object.dir/src_generated/ua_transport_generated.c.o
[ 31%] Building C object CMakeFiles/open62541-object.dir/src/ua_connection.c.o
[ 34%] Building C object CMakeFiles/open62541-object.dir/src/ua_securechannel.c.o
[ 37%] Building C object CMakeFiles/open62541-object.dir/src/ua_session.c.o
[ 41%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_server.c.o
[ 44%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_server_addressspace.c.o
[ 48%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_server_binary.c.o
[ 51%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_nodes.c.o
[ 55%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_server_worker.c.o
[ 58%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_securechannel_manager.c.o
[ 62%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_session_manager.c.o
[ 65%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_discovery.c.o
[ 68%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_securechannel.c.o
[ 72%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_session.c.o
[ 75%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_attribute.c.o
[ 79%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_nodemanagement.c.o
[ 82%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_view.c.o
[ 86%] Building C object CMakeFiles/open62541-object.dir/src/client/ua_client.c.o
[ 89%] Building C object CMakeFiles/open62541-object.dir/examples/networklayer_tcp.c.o
[ 93%] Building C object CMakeFiles/open62541-object.dir/examples/logger_stdout.c.o
[ 96%] Building C object CMakeFiles/open62541-object.dir/src_generated/ua_namespaceinit_generated.c.o
</pre></div>
</div>
<p>And at this point, you are going to see the compiler hanging again. If you specified <code class="docutils literal"><span class="pre">-DCMAKE_BUILD_TYPE=Debug</span></code>, you are looking at about 5-10 seconds of waiting. If you forgot, you can now drink a cup of coffee, go to the movies or take a loved one out for dinner (or abort the build with CTRL+C). Shortly after:</p>
<div class="highlight-python"><div class="highlight"><pre>[ 83%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_services_call.c.o
[ 86%] Building C object CMakeFiles/open62541-object.dir/src/server/ua_nodestore.c.o
[100%] Built target open62541-object
Scanning dependencies of target open62541
Linking C shared library libopen62541.so
[100%] Built target open62541
</pre></div>
</div>
<p>If you open the header <code class="docutils literal"><span class="pre">src_generated/ua_namespaceinit_generated.h</span></code> and take a short look at the generated defines, you will notice the following definitions have been created:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define UA_NS1ID_PROVIDESINPUTTO</span>
<span class="c">#define UA_NS1ID_FIELDDEVICE</span>
<span class="c">#define UA_NS1ID_PUMP</span>
<span class="c">#define UA_NS1ID_STARTPUMP</span>
<span class="c">#define UA_NS1ID_STOPPUMP</span>
</pre></div>
</div>
<p>These definitions are generated for all types, but not variables, objects or views (as their names may be ambiguous and may not a be unique identifier). You can use these definitions in your code as you already used the <code class="docutils literal"><span class="pre">UA_NS0ID_</span></code> equivalents.</p>
<p>Now switch back to your own source directory and update your libopen62541 library (in case you have not linked it into the build folder). Compile our example server as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>ichrispa@Cassandra:open62541/build-tutorials&gt; gcc -g -std=c99 -Wl,-rpath,`pwd` -I ./include -L . -DENABLE_METHODCALLS -o server ./server.c -lopen62541
</pre></div>
</div>
<p>Note that we need to also define the method-calls here, as the header files may choose to ommit functions such as UA_Server_addMethodNode() if they believe you do not use them. If you run the server, you should now see a new dataType in the browse path <code class="docutils literal"><span class="pre">/Types/ObjectTypes/BaseObjectType/FieldDevice</span></code> when viewing the nodes in UAExpert.</p>
<p>If you take a look at any of the variables, like <code class="docutils literal"><span class="pre">ManufacturerName</span></code>, you will notice it is shown as a Boolean; this is not an error. The node does not include a variant and as you learned in our previous tutorial, it is that variant that would hold the dataType ID.</p>
<dl class="docutils">
<dt>A minor list of some of the miriad things that can go wrong:</dt>
<dd><ul class="first last simple">
<li>Your file was not found. The namespace compiler will complain, print a help message, and exit.</li>
<li>A structure/DataType you created with a value was not encoded. The namespace compiler can currently not handle nested extensionObjects.</li>
<li>Nodes are not or wrongly encoded or you get nodeId errors.  The namespace compiler can currently not encode bytestring or guid node id&#8217;s and external server uris are not supported either.</li>
<li>You get compiler complaints for non-existant variants. Check that you have removed any namespace qualifiers (like &#8220;uax:&#8221;) from the XML file.</li>
<li>You get &#8220;invalid reference to addMethodNode&#8221; style errors. Make sure <code class="docutils literal"><span class="pre">-DDENABLE_METHODCALLS=On</span></code> is defined.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="creating-object-instances">
<h2>Creating object instances<a class="headerlink" href="#creating-object-instances" title="Permalink to this headline">¶</a></h2>
<p>Defining an object type is only usefull if it ends up making our lives easier in some way (though it is always the proper thing to do). One of the key benefits of defining object types is being able to create object instances fairly easily. As an example, we will modify the server to create 2 pump instances:</p>
<div class="highlight-python"><div class="highlight"><pre>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

# include &quot;ua_types.h&quot;
# include &quot;ua_server.h&quot;
# include &quot;ua_namespaceinit_generated.h&quot;
# include &quot;logger_stdout.h&quot;
# include &quot;networklayer_tcp.h&quot;

UA_Boolean running;
UA_Int32 global_accessCounter = 0;

void stopHandler(int signal) {
  running = 0;
}

UA_StatusCode pumpInstantiationCallback(UA_NodeId objectId, UA_NodeId definitionId, void *handle);
UA_StatusCode pumpInstantiationCallback(UA_NodeId objectId, UA_NodeId definitionId, void *handle) {
  printf(&quot;Created new node ns=%d;i=%d according to template ns=%d;i=%d (handle was %d)\n&quot;, objectId.namespaceIndex, objectId.identifier.numeric,
          definitionId.namespaceIndex, definitionId.identifier.numeric, *((UA_Int32 *) handle));
  return UA_STATUSCODE_GOOD;
}

int main(void) {
  signal(SIGINT,  stopHandler);
  signal(SIGTERM, stopHandler);

  UA_Server *server = UA_Server_new(UA_ServerConfig_standard);
  UA_Server_addNetworkLayer(server, ServerNetworkLayerTCP_new(UA_ConnectionConfig_standard, 16664));
  running = UA_TRUE;

  UA_Int32 myHandle = 42;
  UA_Server_addInstanceOf(server, UA_NODEID_NUMERIC(1, 0),
                          UA_QUALIFIEDNAME(1, &quot;Pump1&quot;), UA_LOCALIZEDTEXT(&quot;en_US&quot;,&quot;Pump1&quot;), UA_LOCALIZEDTEXT(&quot;en_US&quot;,&quot;A pump!&quot;),
                          UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER), UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES),
                          0, 0, UA_EXPANDEDNODEID_NUMERIC(1, UA_NS1ID_PUMP), pumpInstantiationCallback, (void *) &amp;myHandle, NULL);

  UA_Server_addInstanceOf(server, UA_NODEID_NUMERIC(1, 0),
                          UA_QUALIFIEDNAME(1, &quot;Pump2&quot;), UA_LOCALIZEDTEXT(&quot;en_US&quot;,&quot;Pump2&quot;), UA_LOCALIZEDTEXT(&quot;en_US&quot;,&quot;Another pump!&quot;),
                          UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER), UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES),
                          0, 0, UA_EXPANDEDNODEID_NUMERIC(1, UA_NS1ID_PUMP), pumpInstantiationCallback, (void *) &amp;myHandle, NULL);

  UA_Server_run(server, 1, &amp;running);
  UA_Server_delete(server);

  printf(&quot;Bye\n&quot;);
  return 0;
}
</pre></div>
</div>
<p>Make sure you have updated the headers and libs in your project, then recompile and run the server. Make especially sure you have added <code class="docutils literal"><span class="pre">ua_namespaceinit_generated.h</span></code> to your include folder and that you have removed any references to header in <code class="docutils literal"><span class="pre">server</span></code>. The only include you are going to need is <code class="docutils literal"><span class="pre">ua_types.h</span></code>.</p>
<p>As you can see instantiating an object is not much different from creating an object node. The main difference is that you <em>must</em> use an objectType node as typeDefinition and you (may) pass a callback function (<code class="docutils literal"><span class="pre">pumpInstantiationCallback</span></code>) and a handle (<code class="docutils literal"><span class="pre">myHandle</span></code>). You should already be familiar with callbacks and handles from our previous tutorial and you can easily derive how the callback is used by running the server binary, which produces the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>Created new node ns=1;i=1505 according to template ns=1;i=6001 (handle was 42)
Created new node ns=1;i=1506 according to template ns=1;i=6002 (handle was 42)
Created new node ns=1;i=1507 according to template ns=1;i=6003 (handle was 42)
Created new node ns=1;i=1508 according to template ns=1;i=6004 (handle was 42)
Created new node ns=1;i=1510 according to template ns=1;i=6001 (handle was 42)
Created new node ns=1;i=1511 according to template ns=1;i=6002 (handle was 42)
Created new node ns=1;i=1512 according to template ns=1;i=6003 (handle was 42)
Created new node ns=1;i=1513 according to template ns=1;i=6004 (handle was 42)
</pre></div>
</div>
<p>If you start the server and inspect the nodes with UA Expert, you will find two pumps in the objects folder, which look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>+------------+
| &lt;&lt;Object&gt;&gt; |
|   Pump1    |
+------------+
       |
       |  +------------------+
       |-&gt;|   &lt;&lt;Variable&gt;&gt;   |
       |  | ManufacturerName |
       |  +------------------+
       |  +------------------+
       |  |   &lt;&lt;Variable&gt;&gt;   |
       |-&gt;|    ModelName     |
       |  +------------------+
       |  +------------------+
       |  |   &lt;&lt;Variable&gt;&gt;   |
       |-&gt;|     MotorRPM     |
       |  +------------------+
       |  +------------------+
       |  |   &lt;&lt;Variable&gt;&gt;   |
       |-&gt;|       isOn       |
       |  +------------------+
       |  +------------------+    +------------------+
       |  |    &lt;&lt;Method&gt;&gt;    |    |   &lt;&lt;Variable&gt;&gt;   |
       |-&gt;|    startPump     |---&gt;| outputArguments  |
       |  +------------------+    +------------------+
       |  +------------------+    +------------------+
       |  |    &lt;&lt;Method&gt;&gt;    |    |   &lt;&lt;Variable&gt;&gt;   |
       &#39;-&gt;|     stopPump     |---&gt;| outputArguments  |
          +------------------+    +------------------+
</pre></div>
</div>
<p>As you can see the pump has inherited it&#8217;s parents attributes (ManufacturerName and ModelName). You may also notice that the callback was not called for the methods, even though they are obviously where they are supposed to be. Methods, in contrast to objects and variables, are never cloned but instead only linked. The reason is that you will quite propably attach a method callback to a central method, not each object. Objects are instantiated if they are <em>below</em> the object you are creating, so any object (like an object called associatedServer of ServerType) that is part of pump will be instantiated as well. Objects <em>above</em> you object are never instantiated, so the same ServerType object in Fielddevices would have been ommitted (the reason is that the recursive instantiation function protects itself from infinite recursions, which are hard to track when first ascending, then redescending into a tree).</p>
<p>For each object and variable created by the call, the callback was invoked. The callback gives you the nodeId of the new node along with the Id of the Type template used to create it. You can thereby effectively use setAttributeValue() functions (or others) to adapt the properties of these new nodes, as they can be identified by there templates.</p>
<p>If you want to overwrite an attribute of the parent definition, you will have to delete the node instantiated by the parent&#8217;s template (this as a <strong>FIXME</strong> for developers).</p>
</div>
<div class="section" id="iterating-over-child-nodes">
<h2>Iterating over Child nodes<a class="headerlink" href="#iterating-over-child-nodes" title="Permalink to this headline">¶</a></h2>
<p>A common usecase is wanting to perform something akin to <code class="docutils literal"><span class="pre">for</span> <span class="pre">each</span> <span class="pre">node</span> <span class="pre">referenced</span> <span class="pre">by</span> <span class="pre">X,</span> <span class="pre">call</span> <span class="pre">...</span></code>; you may for example be searching for a specific browseName or instance which was created with a dynamic nodeId. There is no way of telling what you are searching for beforehand (inverse hasComponents, typedefinitions, etc.), but all usescases of &#8220;searching for&#8221; basically means iterating over each reference of a node.</p>
<p>Since searching in nodes is a common operation, the high-level branch provides a function to help you perform this operation:  <code class="docutils literal"><span class="pre">UA_(Server|Client)_forEachChildNodeCall();</span></code>. These functions will iterate over all references of a given node, invoking a callback (with a handle) for every found reference. Since in our last tutorial we created a server that instantiates two pumps, we are now going to build a client that will search for pumps in all object instances on the server.:</p>
<div class="highlight-python"><div class="highlight"><pre>#include &lt;stdio.h&gt;

#include &quot;ua_types.h&quot;
#include &quot;ua_server.h&quot;
#include &quot;ua_client.h&quot;
#include &quot;ua_namespaceinit_generated.h&quot;
#include &quot;logger_stdout.h&quot;
#include &quot;networklayer_tcp.h&quot;

UA_StatusCode nodeIter(UA_NodeId childId, UA_Boolean isInverse, UA_NodeId referenceTypeId, void *handle);
UA_StatusCode nodeIter(UA_NodeId childId, UA_Boolean isInverse, UA_NodeId referenceTypeId, void *handle) {
  struct {
    UA_Client *client;
    UA_Boolean isAPump;
    UA_NodeId PumpId;
  } *nodeIterParam = handle;

  if (isInverse == UA_TRUE)
    return UA_STATUSCODE_GOOD;
  if (childId.namespaceIndex != 1)
    return UA_STATUSCODE_GOOD;
  if (nodeIterParam == NULL)
    return UA_STATUSCODE_GOODNODATA;

  UA_QualifiedName *childBrowseName = NULL;
  UA_Client_getAttributeValue(nodeIterParam-&gt;client, childId, UA_ATTRIBUTEID_BROWSENAME, (void**) &amp;childBrowseName);

  UA_String pumpName = UA_STRING(&quot;Pump&quot;);
  if (childBrowseName != NULL) {
    if (childBrowseName-&gt;namespaceIndex == 1) {
      if (!strncmp(childBrowseName-&gt;name.data, pumpName.data, pumpName.length))
        printf(&quot;Found %s with NodeId ns=1,i=%d\n&quot;, childBrowseName-&gt;name.data, childId.identifier.numeric);
        inodeIterParam-&gt;isAPump = UA_TRUE;
        UA_NodeId_copy(&amp;childId, &amp;nodeIterParam-&gt;PumpId);
    }
  }

  UA_QualifiedName_delete(childBrowseName);
  return UA_STATUSCODE_GOOD;
}

int main(void) {
  UA_Client *client = UA_Client_new(UA_ClientConfig_standard, Logger_Stdout_new());
  UA_StatusCode retval = UA_Client_connect(client, ClientNetworkLayerTCP_connect, &quot;opc.tcp://localhost:16664&quot;);
  if(retval != UA_STATUSCODE_GOOD) {
    UA_Client_delete(client);
    return retval;
  }

  struct {
    UA_Client *client;
    UA_Boolean isAPump;
    UA_NodeId PumpId;
  } nodeIterParam;
  nodeIterParam.client = client;
  nodeIterParam.isAPump = UA_FALSE;

  UA_Client_forEachChildNodeCall(client, UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER), nodeIter, (void *) &amp;nodeIterParam);
  if (nodeIterParam.isAPump == UA_TRUE)
    printf(&quot;Found at least one pump\n&quot;);

  UA_Client_disconnect(client);
  UA_Client_delete(client);
  return 0;
}
</pre></div>
</div>
<p>If the client is run while the example server is running in the background, it will produce the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>Found Pump1 with NodeId ns=1,i=1504
Found Pump2 with NodeId ns=1,i=1509
</pre></div>
</div>
<p>How does it work? The nodeIter function is called by UA_Client_forEachChildNodeCall() for each reference contained in the objectsFolder. The iterator is passed the id of the target and the type of the reference, along with the references directionality. Since we are browsing the Object node, this iterator will be called mutliple times, indicating links to the root node, server, the two pump instances and the nodes type definition.</p>
<p>We are only interested in nodes in namespace 1 that are referenced forwardly, so the iterator returns early if these conditions are not met.</p>
<p>We are searching the nodes by name, so we are comparing the name of the nodes to a string; We could also (in a more complicated example) repeat the node iteration inside the iterator, ie inspect the references of each node to see if it has the dataType &#8220;Pump&#8221;, which would be a more reliable way to operate this sort of search. In either case we need to pass parameters to and from the iterator(s). Note the plural.</p>
<p>You can use the handle to contain a pointer to a struct, which can hold multiple arguments as in the example above. In a more thorough example, the field PumpId could have been an array or a linked list. That struct could also be defined as a global dataType instead of using in-function definitions. Since the handle can be passed between multiple calls of iterators (or any other function that accept handles), the data contents can be communicated between different functions easily.</p>
</div>
<div class="section" id="examining-node-copies">
<h2>Examining node copies<a class="headerlink" href="#examining-node-copies" title="Permalink to this headline">¶</a></h2>
<p>So far we have always used the getAttribute() functions to inspect node contents. There may be isolated cases where these are insuficient because you want to examine the properties of a node &#8220;in bulk&#8221;. As mentioned in the first tutorials, the user can not directly interact with the servers nodestore; but the userspace may request a copy of a node, including all its attributes and references. The following functions server the purpose of getting and getting rid of node copies:</p>
<div class="highlight-python"><div class="highlight"><pre>UA_(Server|Client)_getNodeCopy()
UA_(Server|Client)_destroyNodeCopy()
</pre></div>
</div>
<p>Since you are trying to see a struct (node types) that are usually hidden from userspace, you will have to include <code class="docutils literal"><span class="pre">include/ua_nodes.h</span></code>, <code class="docutils literal"><span class="pre">src/ua_types_encoding_binary.h</span></code> and <code class="docutils literal"><span class="pre">deps/queue.h</span></code> in addition to the previous includes (link them into the includes folder).</p>
<p>Let&#8217;s suppose we wanted to do something elaborate with our pump instance that was returned by the iterator of the previous example, or simply &#8220;print&#8221; all its fields. We could modify the above client&#8217;s main function like so:</p>
<div class="highlight-python"><div class="highlight"><pre>int main(void) {
  UA_Client *client = UA_Client_new(UA_ClientConfig_standard, Logger_Stdout_new());
  UA_StatusCode retval = UA_Client_connect(client, ClientNetworkLayerTCP_connect, &quot;opc.tcp://localhost:16664&quot;);
  if(retval != UA_STATUSCODE_GOOD) {
    UA_Client_delete(client);
    return retval;
  }

  struct {
    UA_Client *client;
    UA_Boolean isAPump;
    UA_NodeId PumpId;
  } nodeIterParam;
  nodeIterParam.client = client;
  nodeIterParam.isAPump = UA_FALSE;

  UA_Client_forEachChildNodeCall(client, UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER), nodeIter, (void *) &amp;nodeIterParam);
  if (nodeIterParam.isAPump == UA_TRUE) {
    UA_ObjectNode *aPump;
    UA_Client_getNodeCopy(client, nodeIterParam.PumpId, (void **) &amp;aPump);
    printf(&quot;The pump %s with NodeId ns=1,i=%d was returned\n&quot;, aPump-&gt;browseName.name.data, aPump-&gt;nodeId.identifier.numeric);
    UA_Client_deleteNodeCopy(client, (void **) &amp;aPump);
  }

  UA_Client_disconnect(client);
  UA_Client_delete(client);
  return 0;
}
</pre></div>
</div>
<p><strong>Warning</strong> in both examples, we are printing strings contained in UA_String types. These are fundamentaly different from strings in C in that they are <em>not</em> necessarlity NULL terminated; they are exactly as long as the string length indicates. It is quite possible that printf() will keep printing trailing data after the UA_String until it finds a NULL. If you intend to really print strings in an application, use the &#8220;length&#8221; field of the UA_String struct to allocate a null-initialized buffer, then copy the string data into that buffer before printing it.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this tutorial, you have learned how to compile your own namespaces, instantiate data and examine the relations of the new nodes. You have learned about node iterators and how to pack multiple pass-through parameters into handles; a technique that is by no means limited to iterators but can also be applied to any other callback, such as methods or value sources.</p>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, The open62541 authors.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>