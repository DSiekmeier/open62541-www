<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="group__nodestore" kind="group">
    <compoundname>nodestore</compoundname>
    <title>NodeStore</title>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" prot="public" static="no">
        <type>struct <ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref></type>
        <definition>typedef struct UA_NodeStore UA_NodeStore</definition>
        <argsstring></argsstring>
        <name>UA_NodeStore</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="36" bodyfile="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__nodestore_1gaf4a4a284506499e2a78e9a8814a88161" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* UA_NodeStore_nodeVisitor)(const UA_Node *node)</definition>
        <argsstring>)(const UA_Node *node)</argsstring>
        <name>UA_NodeStore_nodeVisitor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A function that can be evaluated on all entries in a nodestore via UA_NodeStore_iterate. Note that the visitor is read-only on the nodes. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="81" bodyfile="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" bodystart="81" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__nodestore_1ga24dbca297c72477ab2144076ec807307" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
        <definition>UA_NodeStore* UA_NodeStore_new</definition>
        <argsstring>(void)</argsstring>
        <name>UA_NodeStore_new</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new nodestore </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="39"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1ga754d4517ad53cb4286592713d9981152" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UA_NodeStore_delete</definition>
        <argsstring>(UA_NodeStore *ns)</argsstring>
        <name>UA_NodeStore_delete</name>
        <param>
          <type><ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete the nodestore and all nodes in it. Do not call from a read-side critical section (multithreading). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="43"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1ga7ca8212432713ff12297594423b40062" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="ua__statuscodes_8h_1a82f92964aaa5dd1c5a1c5d7e9099883c" kindref="member">UA_StatusCode</ref></type>
        <definition>UA_StatusCode UA_NodeStore_insert</definition>
        <argsstring>(UA_NodeStore *ns, UA_Node *node, UA_MT_CONST UA_Node **inserted)</argsstring>
        <name>UA_NodeStore_insert</name>
        <param>
          <type><ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <param>
          <type><ref refid="structUA__Node" kindref="compound">UA_Node</ref> *</type>
          <declname>node</declname>
        </param>
        <param>
          <type><ref refid="group__nodestore_1ga5c2220bfe9bf50a63c6311967eb5323d" kindref="member">UA_MT_CONST</ref> <ref refid="structUA__Node" kindref="compound">UA_Node</ref> **</type>
          <declname>inserted</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Inserts a new node into the nodestore. If the nodeid is zero, then a fresh numeric nodeid from nodestore 1 is assigned. The memory of the original node is freed and the content is moved to a managed (immutable) node. If inserted is not NULL, then a pointer to the managed node is returned (and must be released). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="52"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1ga7a20161e031b0d504ed2bc3a4a166843" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="ua__statuscodes_8h_1a82f92964aaa5dd1c5a1c5d7e9099883c" kindref="member">UA_StatusCode</ref></type>
        <definition>UA_StatusCode UA_NodeStore_replace</definition>
        <argsstring>(UA_NodeStore *ns, UA_MT_CONST UA_Node *oldNode, UA_Node *node, UA_MT_CONST UA_Node **inserted)</argsstring>
        <name>UA_NodeStore_replace</name>
        <param>
          <type><ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <param>
          <type><ref refid="group__nodestore_1ga5c2220bfe9bf50a63c6311967eb5323d" kindref="member">UA_MT_CONST</ref> <ref refid="structUA__Node" kindref="compound">UA_Node</ref> *</type>
          <declname>oldNode</declname>
        </param>
        <param>
          <type><ref refid="structUA__Node" kindref="compound">UA_Node</ref> *</type>
          <declname>node</declname>
        </param>
        <param>
          <type><ref refid="group__nodestore_1ga5c2220bfe9bf50a63c6311967eb5323d" kindref="member">UA_MT_CONST</ref> <ref refid="structUA__Node" kindref="compound">UA_Node</ref> **</type>
          <declname>inserted</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace an existing node in the nodestore. If the node was already replaced, UA_STATUSCODE_BADINTERNALERROR is returned. A pointer to the inserted node is returned. It is important that oldNode is not used afterwards in the same thread. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="61"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1ga6f17e438ced10fd4c1f035a930acd23a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="ua__statuscodes_8h_1a82f92964aaa5dd1c5a1c5d7e9099883c" kindref="member">UA_StatusCode</ref></type>
        <definition>UA_StatusCode UA_NodeStore_remove</definition>
        <argsstring>(UA_NodeStore *ns, const UA_NodeId *nodeid)</argsstring>
        <name>UA_NodeStore_remove</name>
        <param>
          <type><ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <param>
          <type>const <ref refid="structUA__NodeId" kindref="compound">UA_NodeId</ref> *</type>
          <declname>nodeid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove a node from the nodestore. Always succeeds, even if the node was not found. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="67"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1gacce69f56219fb4851eff30f104616e95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__nodestore_1ga5c2220bfe9bf50a63c6311967eb5323d" kindref="member">UA_MT_CONST</ref> <ref refid="structUA__Node" kindref="compound">UA_Node</ref> *</type>
        <definition>UA_MT_CONST UA_Node* UA_NodeStore_get</definition>
        <argsstring>(const UA_NodeStore *ns, const UA_NodeId *nodeid)</argsstring>
        <name>UA_NodeStore_get</name>
        <param>
          <type>const <ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <param>
          <type>const <ref refid="structUA__NodeId" kindref="compound">UA_NodeId</ref> *</type>
          <declname>nodeid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Retrieve a managed node (read-only) from the nodestore. Nodes are reference- counted (for garbage collection) and immutable. They can only be replaced entirely. After the node is no longer used, it needs to be released to decrease the reference count. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="75"/>
      </memberdef>
      <memberdef kind="function" id="group__nodestore_1ga3bf247b62795b6a53bb551124a41e4f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void UA_NodeStore_iterate</definition>
        <argsstring>(const UA_NodeStore *ns, UA_NodeStore_nodeVisitor visitor)</argsstring>
        <name>UA_NodeStore_iterate</name>
        <param>
          <type>const <ref refid="group__nodestore_1ga6a58ef1e1f4671734067273d69a4dec6" kindref="member">UA_NodeStore</ref> *</type>
          <declname>ns</declname>
        </param>
        <param>
          <type><ref refid="group__nodestore_1gaf4a4a284506499e2a78e9a8814a88161" kindref="member">UA_NodeStore_nodeVisitor</ref></type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Iterate over all nodes in a nodestore. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="84"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__nodestore_1ga5c2220bfe9bf50a63c6311967eb5323d" prot="public" static="no">
        <name>UA_MT_CONST</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" line="32" bodyfile="/home/travis/build/acplt/open62541/src/server/ua_nodestore.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Stores the nodes in the address space. Internally, it is based on a hash-map that maps nodes to their nodeid. </para>    </briefdescription>
    <detaileddescription>
<para>Nodes need to be allocated on the heap before adding them to the nodestore with. When adding, the node is copied to a new (managed) location in the nodestore and the original memory is freed. The nodes in the nodestore are immutable. To change the content of a node, it needs to be replaced as a whole.</para><para>Every node you _get from the nodestore needs to be _released when it is no longer needed. In the background, reference counting is used to know if somebody still uses the node in multi-threaded environments. </para>    </detaileddescription>
  </compounddef>
</doxygen>
